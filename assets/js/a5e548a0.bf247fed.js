"use strict";(globalThis.webpackChunkai_robotics_book=globalThis.webpackChunkai_robotics_book||[]).push([[7736],{1127:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>i,metadata:()=>t,toc:()=>p});const t=JSON.parse('{"id":"module-3-isaac/nav2-bipedal","title":"Nav2 for Bipedal Robots","description":"Adapting ROS 2 Navigation Stack for humanoid robot locomotion","source":"@site/docs/module-3-isaac/04-nav2-bipedal.md","sourceDirName":"module-3-isaac","slug":"/module-3-isaac/nav2-bipedal","permalink":"/ai-robotics-book/docs/module-3-isaac/nav2-bipedal","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Nav2 for Bipedal Robots","description":"Adapting ROS 2 Navigation Stack for humanoid robot locomotion"},"sidebar":"tutorialSidebar","previous":{"title":"Visual SLAM","permalink":"/ai-robotics-book/docs/module-3-isaac/vslam"},"next":{"title":"Module 4: Vision-Language-Action Models","permalink":"/ai-robotics-book/docs/category/module-4-vision-language-action-models"}}');var o=s(4848),r=s(8453);const i={sidebar_position:4,title:"Nav2 for Bipedal Robots",description:"Adapting ROS 2 Navigation Stack for humanoid robot locomotion"},a="Nav2 for Bipedal Robots",l={},p=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Nav2 Architecture for Humanoids",id:"nav2-architecture-for-humanoids",level:2},{value:"Key Differences from Wheeled Robots",id:"key-differences-from-wheeled-robots",level:3},{value:"Nav2 Configuration",id:"nav2-configuration",level:2},{value:"Custom Parameters for Bipedal",id:"custom-parameters-for-bipedal",level:3},{value:"Footstep Planning",id:"footstep-planning",level:2},{value:"Footstep Planner Implementation",id:"footstep-planner-implementation",level:3},{value:"Terrain Assessment",id:"terrain-assessment",level:2},{value:"Terrain Layer Plugin",id:"terrain-layer-plugin",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Configure Nav2 for Humanoid",id:"exercise-1-configure-nav2-for-humanoid",level:3},{value:"Exercise 2: Implement Footstep Planner",id:"exercise-2-implement-footstep-planner",level:3},{value:"Exercise 3: Terrain Assessment",id:"exercise-3-terrain-assessment",level:3},{value:"Assessment Questions",id:"assessment-questions",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"nav2-for-bipedal-robots",children:"Nav2 for Bipedal Robots"})}),"\n",(0,o.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,o.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Configure"})," Nav2 for bipedal locomotion constraints"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Implement"})," custom motion planners for humanoid robots"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Design"})," footstep planning integration with Nav2"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Handle"})," terrain assessment for safe walking"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Create"})," behavior trees for complex navigation tasks"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Completed Chapters 1-3 of Module 3"}),"\n",(0,o.jsx)(n.li,{children:"Understanding of Nav2 architecture"}),"\n",(0,o.jsx)(n.li,{children:"Familiarity with path planning concepts"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"nav2-architecture-for-humanoids",children:"Nav2 Architecture for Humanoids"}),"\n",(0,o.jsx)(n.p,{children:"The ROS 2 Navigation Stack (Nav2) requires adaptation for bipedal robots due to their unique locomotion constraints."}),"\n",(0,o.jsx)(n.mermaid,{value:'graph TB\n    subgraph "Standard Nav2"\n        BT[Behavior Tree]\n        PLAN[Global Planner]\n        CTRL[Controller]\n        LOC[Localization]\n    end\n\n    subgraph "Humanoid Extensions"\n        FP[Footstep Planner]\n        TA[Terrain Assessment]\n        BAL[Balance Controller]\n        GAIT[Gait Generator]\n    end\n\n    BT --\x3e PLAN\n    PLAN --\x3e FP\n    FP --\x3e TA\n    TA --\x3e GAIT\n    GAIT --\x3e BAL\n    BAL --\x3e CTRL\n    LOC --\x3e BT\n\n    style FP fill:#76b900,color:white\n    style GAIT fill:#c8e6c9'}),"\n",(0,o.jsx)(n.h3,{id:"key-differences-from-wheeled-robots",children:"Key Differences from Wheeled Robots"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Aspect"}),(0,o.jsx)(n.th,{children:"Wheeled"}),(0,o.jsx)(n.th,{children:"Bipedal"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Motion model"}),(0,o.jsx)(n.td,{children:"Continuous"}),(0,o.jsx)(n.td,{children:"Discrete footsteps"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Stability"}),(0,o.jsx)(n.td,{children:"Static"}),(0,o.jsx)(n.td,{children:"Dynamic balance"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Terrain"}),(0,o.jsx)(n.td,{children:"Flat surfaces"}),(0,o.jsx)(n.td,{children:"Steps, slopes, obstacles"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Speed"}),(0,o.jsx)(n.td,{children:"Fast"}),(0,o.jsx)(n.td,{children:"Slower, deliberate"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Recovery"}),(0,o.jsx)(n.td,{children:"Simple"}),(0,o.jsx)(n.td,{children:"Complex fall recovery"})]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"nav2-configuration",children:"Nav2 Configuration"}),"\n",(0,o.jsx)(n.h3,{id:"custom-parameters-for-bipedal",children:"Custom Parameters for Bipedal"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'# nav2_params.yaml\nnav2_bt_navigator:\n  ros__parameters:\n    use_sim_time: true\n    global_frame: map\n    robot_base_frame: base_link\n    odom_topic: /odom\n    # Longer timeouts for slower humanoid motion\n    bt_loop_duration: 20\n    default_server_timeout: 30\n    plugin_lib_names:\n      - nav2_compute_path_to_pose_action_bt_node\n      - nav2_follow_path_action_bt_node\n      - nav2_humanoid_footstep_planner_bt_node  # Custom\n\nglobal_costmap:\n  global_costmap:\n    ros__parameters:\n      update_frequency: 1.0\n      publish_frequency: 1.0\n      global_frame: map\n      robot_base_frame: base_link\n      robot_radius: 0.3  # Humanoid footprint\n      resolution: 0.05\n      track_unknown_space: true\n      plugins: ["static_layer", "obstacle_layer", "terrain_layer", "inflation_layer"]\n\n      terrain_layer:\n        plugin: "humanoid_nav2/TerrainAssessmentLayer"\n        enabled: true\n        max_step_height: 0.15  # 15cm max step\n        max_slope_angle: 15.0  # 15 degree max slope\n        min_foothold_size: 0.1  # 10cm minimum foothold\n\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 5.0\n        inflation_radius: 0.5\n\nlocal_costmap:\n  local_costmap:\n    ros__parameters:\n      update_frequency: 5.0\n      publish_frequency: 2.0\n      global_frame: odom\n      robot_base_frame: base_link\n      rolling_window: true\n      width: 3\n      height: 3\n      resolution: 0.025\n      robot_radius: 0.3\n\ncontroller_server:\n  ros__parameters:\n    use_sim_time: true\n    controller_frequency: 20.0  # Lower for bipedal\n    min_x_velocity_threshold: 0.001\n    min_y_velocity_threshold: 0.001\n    min_theta_velocity_threshold: 0.001\n    controller_plugins: ["HumanoidController"]\n\n    HumanoidController:\n      plugin: "humanoid_nav2::BipedalController"\n      max_vel_x: 0.3  # Slower than wheeled\n      max_vel_theta: 0.5\n      footstep_duration: 0.8\n      double_support_ratio: 0.2\n\nplanner_server:\n  ros__parameters:\n    expected_planner_frequency: 1.0  # Slower planning\n    planner_plugins: ["GridBased", "FootstepPlanner"]\n\n    GridBased:\n      plugin: "nav2_navfn_planner/NavfnPlanner"\n      tolerance: 0.5\n      use_astar: true\n\n    FootstepPlanner:\n      plugin: "humanoid_nav2::FootstepPlanner"\n      step_length: 0.25\n      step_width: 0.1\n      turning_step_angle: 0.2\n      max_step_height: 0.15\n'})}),"\n",(0,o.jsx)(n.h2,{id:"footstep-planning",children:"Footstep Planning"}),"\n",(0,o.jsx)(n.h3,{id:"footstep-planner-implementation",children:"Footstep Planner Implementation"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""Custom footstep planner for humanoid navigation."""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionServer\nfrom nav2_msgs.action import ComputePathToPose\nfrom geometry_msgs.msg import PoseStamped, Pose\nfrom visualization_msgs.msg import MarkerArray, Marker\nimport numpy as np\nfrom dataclasses import dataclass\nfrom typing import List, Tuple\nfrom enum import Enum\n\n\nclass FootSide(Enum):\n    LEFT = 0\n    RIGHT = 1\n\n\n@dataclass\nclass Footstep:\n    """Single footstep specification."""\n    pose: Pose\n    side: FootSide\n    duration: float = 0.8\n    step_height: float = 0.05\n\n\nclass FootstepPlanner(Node):\n    """Plan footsteps along a path."""\n\n    def __init__(self):\n        super().__init__(\'footstep_planner\')\n\n        # Parameters\n        self.declare_parameter(\'step_length\', 0.25)\n        self.declare_parameter(\'step_width\', 0.20)\n        self.declare_parameter(\'turning_step_angle\', 0.2)\n        self.declare_parameter(\'default_step_height\', 0.05)\n\n        self.step_length = self.get_parameter(\'step_length\').value\n        self.step_width = self.get_parameter(\'step_width\').value\n        self.turning_angle = self.get_parameter(\'turning_step_angle\').value\n        self.step_height = self.get_parameter(\'default_step_height\').value\n\n        # Current foot (alternates)\n        self.current_foot = FootSide.LEFT\n\n        # Footstep publisher for visualization\n        self.footstep_pub = self.create_publisher(\n            MarkerArray, \'/footstep_plan\', 10\n        )\n\n        # Action server\n        self._action_server = ActionServer(\n            self,\n            ComputePathToPose,\n            \'compute_footsteps\',\n            self.execute_callback\n        )\n\n        self.get_logger().info(\'Footstep planner initialized\')\n\n    def execute_callback(self, goal_handle):\n        """Plan footsteps from current pose to goal."""\n        request = goal_handle.request\n\n        start_pose = request.start\n        goal_pose = request.goal\n\n        # Generate footstep sequence\n        footsteps = self.plan_footsteps(start_pose, goal_pose)\n\n        # Visualize\n        self.publish_footstep_markers(footsteps)\n\n        # Return result\n        result = ComputePathToPose.Result()\n        # Convert footsteps to path (simplified)\n        result.path.header.frame_id = \'map\'\n        result.path.header.stamp = self.get_clock().now().to_msg()\n\n        for fs in footsteps:\n            pose_stamped = PoseStamped()\n            pose_stamped.pose = fs.pose\n            result.path.poses.append(pose_stamped)\n\n        goal_handle.succeed()\n        return result\n\n    def plan_footsteps(self, start: PoseStamped, goal: PoseStamped) -> List[Footstep]:\n        """Generate footstep sequence from start to goal."""\n        footsteps = []\n\n        # Extract positions\n        start_pos = np.array([start.pose.position.x, start.pose.position.y])\n        goal_pos = np.array([goal.pose.position.x, goal.pose.position.y])\n\n        # Direction to goal\n        direction = goal_pos - start_pos\n        distance = np.linalg.norm(direction)\n\n        if distance < 0.01:\n            return footsteps\n\n        direction_normalized = direction / distance\n        heading = np.arctan2(direction_normalized[1], direction_normalized[0])\n\n        # Generate footsteps along path\n        current_pos = start_pos.copy()\n        current_heading = self._get_yaw(start.pose.orientation)\n        current_foot = FootSide.LEFT\n\n        while np.linalg.norm(goal_pos - current_pos) > self.step_length:\n            # Calculate target heading\n            to_goal = goal_pos - current_pos\n            target_heading = np.arctan2(to_goal[1], to_goal[0])\n\n            # Turn if needed\n            heading_error = self._normalize_angle(target_heading - current_heading)\n\n            if abs(heading_error) > self.turning_angle:\n                # Turning step\n                turn_amount = np.sign(heading_error) * min(abs(heading_error), self.turning_angle)\n                current_heading += turn_amount\n            else:\n                # Walking step\n                step_direction = np.array([np.cos(current_heading), np.sin(current_heading)])\n                current_pos += step_direction * self.step_length\n\n            # Create footstep\n            footstep = self._create_footstep(\n                current_pos, current_heading, current_foot\n            )\n            footsteps.append(footstep)\n\n            # Alternate feet\n            current_foot = FootSide.RIGHT if current_foot == FootSide.LEFT else FootSide.LEFT\n\n        # Final step to goal\n        final_footstep = self._create_footstep(\n            goal_pos,\n            self._get_yaw(goal.pose.orientation),\n            current_foot\n        )\n        footsteps.append(final_footstep)\n\n        self.get_logger().info(f\'Generated {len(footsteps)} footsteps\')\n        return footsteps\n\n    def _create_footstep(self, position: np.ndarray, heading: float,\n                         side: FootSide) -> Footstep:\n        """Create a footstep at given position."""\n        # Offset based on foot side\n        lateral_offset = self.step_width / 2\n        if side == FootSide.LEFT:\n            lateral_offset = -lateral_offset\n\n        # Calculate foot position with offset\n        offset = np.array([\n            -np.sin(heading) * lateral_offset,\n            np.cos(heading) * lateral_offset\n        ])\n\n        foot_pos = position + offset\n\n        pose = Pose()\n        pose.position.x = float(foot_pos[0])\n        pose.position.y = float(foot_pos[1])\n        pose.position.z = 0.0\n\n        # Quaternion from heading\n        pose.orientation.z = np.sin(heading / 2)\n        pose.orientation.w = np.cos(heading / 2)\n\n        return Footstep(pose=pose, side=side, step_height=self.step_height)\n\n    def _get_yaw(self, q) -> float:\n        """Extract yaw from quaternion."""\n        siny_cosp = 2 * (q.w * q.z + q.x * q.y)\n        cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z)\n        return np.arctan2(siny_cosp, cosy_cosp)\n\n    def _normalize_angle(self, angle: float) -> float:\n        """Normalize angle to [-pi, pi]."""\n        while angle > np.pi:\n            angle -= 2 * np.pi\n        while angle < -np.pi:\n            angle += 2 * np.pi\n        return angle\n\n    def publish_footstep_markers(self, footsteps: List[Footstep]):\n        """Publish footstep visualization markers."""\n        markers = MarkerArray()\n\n        for i, fs in enumerate(footsteps):\n            marker = Marker()\n            marker.header.frame_id = \'map\'\n            marker.header.stamp = self.get_clock().now().to_msg()\n            marker.ns = \'footsteps\'\n            marker.id = i\n            marker.type = Marker.CUBE\n            marker.action = Marker.ADD\n\n            marker.pose = fs.pose\n            marker.pose.position.z = 0.01  # Slightly above ground\n\n            # Foot dimensions\n            marker.scale.x = 0.2   # Length\n            marker.scale.y = 0.1   # Width\n            marker.scale.z = 0.02  # Height\n\n            # Color based on foot side\n            if fs.side == FootSide.LEFT:\n                marker.color.r = 0.2\n                marker.color.g = 0.6\n                marker.color.b = 1.0\n            else:\n                marker.color.r = 1.0\n                marker.color.g = 0.4\n                marker.color.b = 0.2\n            marker.color.a = 0.8\n\n            markers.markers.append(marker)\n\n        self.footstep_pub.publish(markers)\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = FootstepPlanner()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsx)(n.h2,{id:"terrain-assessment",children:"Terrain Assessment"}),"\n",(0,o.jsx)(n.h3,{id:"terrain-layer-plugin",children:"Terrain Layer Plugin"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""Terrain assessment layer for humanoid navigation costmap."""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import PointCloud2\nfrom nav_msgs.msg import OccupancyGrid\nimport numpy as np\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass TerrainCell:\n    """Terrain properties for a single cell."""\n    height: float\n    slope: float\n    roughness: float\n    is_traversable: bool\n\n\nclass TerrainAssessment(Node):\n    """Assess terrain traversability for humanoid walking."""\n\n    def __init__(self):\n        super().__init__(\'terrain_assessment\')\n\n        # Parameters\n        self.declare_parameter(\'max_step_height\', 0.15)\n        self.declare_parameter(\'max_slope_degrees\', 15.0)\n        self.declare_parameter(\'min_foothold_size\', 0.1)\n        self.declare_parameter(\'resolution\', 0.05)\n\n        self.max_step = self.get_parameter(\'max_step_height\').value\n        self.max_slope = np.radians(self.get_parameter(\'max_slope_degrees\').value)\n        self.min_foothold = self.get_parameter(\'min_foothold_size\').value\n        self.resolution = self.get_parameter(\'resolution\').value\n\n        # Subscribers\n        self.pointcloud_sub = self.create_subscription(\n            PointCloud2, \'/terrain/points\',\n            self.pointcloud_callback, 10\n        )\n\n        # Publishers\n        self.terrain_cost_pub = self.create_publisher(\n            OccupancyGrid, \'/terrain_costmap\', 10\n        )\n\n        # Terrain grid\n        self.grid_size = 200  # 10m x 10m at 0.05m resolution\n        self.height_map = np.zeros((self.grid_size, self.grid_size))\n        self.traversability = np.ones((self.grid_size, self.grid_size)) * 100\n\n        self.get_logger().info(\'Terrain assessment initialized\')\n\n    def pointcloud_callback(self, msg: PointCloud2):\n        """Process terrain pointcloud."""\n        # Convert pointcloud to numpy (simplified)\n        points = self._pointcloud_to_numpy(msg)\n\n        if points is None or len(points) == 0:\n            return\n\n        # Update height map\n        self._update_height_map(points)\n\n        # Compute traversability\n        self._compute_traversability()\n\n        # Publish costmap\n        self._publish_costmap()\n\n    def _pointcloud_to_numpy(self, msg: PointCloud2) -> np.ndarray:\n        """Convert PointCloud2 to numpy array."""\n        # Simplified conversion - in practice use ros2_numpy\n        # This is a placeholder\n        return None\n\n    def _update_height_map(self, points: np.ndarray):\n        """Update height map from points."""\n        for point in points:\n            x, y, z = point[:3]\n\n            # Convert to grid indices\n            i = int((x + self.grid_size * self.resolution / 2) / self.resolution)\n            j = int((y + self.grid_size * self.resolution / 2) / self.resolution)\n\n            if 0 <= i < self.grid_size and 0 <= j < self.grid_size:\n                self.height_map[i, j] = z\n\n    def _compute_traversability(self):\n        """Compute traversability cost from height map."""\n        for i in range(1, self.grid_size - 1):\n            for j in range(1, self.grid_size - 1):\n                # Compute local slope\n                dzdx = (self.height_map[i+1, j] - self.height_map[i-1, j]) / (2 * self.resolution)\n                dzdy = (self.height_map[i, j+1] - self.height_map[i, j-1]) / (2 * self.resolution)\n                slope = np.arctan(np.sqrt(dzdx**2 + dzdy**2))\n\n                # Compute step height (max height difference to neighbors)\n                neighbors = self.height_map[i-1:i+2, j-1:j+2]\n                step_height = np.max(np.abs(neighbors - self.height_map[i, j]))\n\n                # Compute cost\n                cost = 0\n\n                # Slope cost\n                if slope > self.max_slope:\n                    cost = 100  # Impassable\n                else:\n                    cost += int(50 * slope / self.max_slope)\n\n                # Step height cost\n                if step_height > self.max_step:\n                    cost = 100  # Impassable\n                else:\n                    cost += int(50 * step_height / self.max_step)\n\n                self.traversability[i, j] = min(cost, 100)\n\n    def _publish_costmap(self):\n        """Publish terrain costmap."""\n        msg = OccupancyGrid()\n        msg.header.frame_id = \'map\'\n        msg.header.stamp = self.get_clock().now().to_msg()\n\n        msg.info.resolution = self.resolution\n        msg.info.width = self.grid_size\n        msg.info.height = self.grid_size\n        msg.info.origin.position.x = -self.grid_size * self.resolution / 2\n        msg.info.origin.position.y = -self.grid_size * self.resolution / 2\n\n        msg.data = self.traversability.flatten().astype(np.int8).tolist()\n\n        self.terrain_cost_pub.publish(msg)\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = TerrainAssessment()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,o.jsx)(n.h3,{id:"exercise-1-configure-nav2-for-humanoid",children:"Exercise 1: Configure Nav2 for Humanoid"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Modify Nav2 parameters for your humanoid robot"}),"\n",(0,o.jsx)(n.li,{children:"Test path planning with slower velocities"}),"\n",(0,o.jsx)(n.li,{children:"Verify footprint and inflation settings"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"exercise-2-implement-footstep-planner",children:"Exercise 2: Implement Footstep Planner"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Complete the footstep planner implementation"}),"\n",(0,o.jsx)(n.li,{children:"Add terrain-aware step height adjustment"}),"\n",(0,o.jsx)(n.li,{children:"Visualize footsteps in RViz"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"exercise-3-terrain-assessment",children:"Exercise 3: Terrain Assessment"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Create a terrain assessment node"}),"\n",(0,o.jsx)(n.li,{children:"Generate costmaps from depth camera data"}),"\n",(0,o.jsx)(n.li,{children:"Test navigation over uneven terrain"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"assessment-questions",children:"Assessment Questions"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"What are the key differences in path planning for bipedal vs wheeled robots?"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"How does terrain assessment affect footstep placement?"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Why is footstep planning discrete rather than continuous?"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"What safety considerations are important for humanoid navigation?"})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"This chapter covered Nav2 adaptation for humanoids:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Nav2 configuration"})," requires adjustments for bipedal constraints"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Footstep planning"})," discretizes paths into individual steps"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Terrain assessment"})," validates traversability for walking"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Behavior trees"})," coordinate complex navigation behaviors"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"This completes Module 3 on NVIDIA Isaac Platform. Next, we'll explore Vision-Language-Action models."}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Next Module"}),": ",(0,o.jsx)(n.a,{href:"../module-4-vla/voice-to-action",children:"Vision-Language-Action Models"})]})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>a});var t=s(6540);const o={},r=t.createContext(o);function i(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);