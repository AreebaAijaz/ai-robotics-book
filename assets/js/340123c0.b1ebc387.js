"use strict";(globalThis.webpackChunkai_robotics_book=globalThis.webpackChunkai_robotics_book||[]).push([[5243],{8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var t=r(6540);const l={},s=t.createContext(l);function o(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:o(e.components),t.createElement(s.Provider,{value:n},e.children)}},9080:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-1-ros2/rclpy-integration","title":"Python Development with rclpy","description":"Advanced Python development for ROS 2 including executors, callback groups, and lifecycle management","source":"@site/docs/module-1-ros2/03-rclpy-integration.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/rclpy-integration","permalink":"/ai-robotics-book/docs/module-1-ros2/rclpy-integration","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Python Development with rclpy","description":"Advanced Python development for ROS 2 including executors, callback groups, and lifecycle management"},"sidebar":"tutorialSidebar","previous":{"title":"Nodes, Topics, and Services","permalink":"/ai-robotics-book/docs/module-1-ros2/nodes-topics-services"},"next":{"title":"URDF for Humanoid Robots","permalink":"/ai-robotics-book/docs/module-1-ros2/urdf-humanoids"}}');var l=r(4848),s=r(8453);const o={sidebar_position:3,title:"Python Development with rclpy",description:"Advanced Python development for ROS 2 including executors, callback groups, and lifecycle management"},a="Python Development with rclpy",i={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Advanced rclpy Concepts",id:"advanced-rclpy-concepts",level:2},{value:"Executors and Callback Groups",id:"executors-and-callback-groups",level:2},{value:"Understanding Executors",id:"understanding-executors",level:3},{value:"Multi-Threaded Execution",id:"multi-threaded-execution",level:3},{value:"Lifecycle Nodes",id:"lifecycle-nodes",level:2},{value:"Implementing a Lifecycle Node",id:"implementing-a-lifecycle-node",level:3},{value:"Managing Lifecycle Nodes",id:"managing-lifecycle-nodes",level:3},{value:"Dynamic Parameters",id:"dynamic-parameters",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Multi-Threaded Sensor Fusion",id:"exercise-1-multi-threaded-sensor-fusion",level:3},{value:"Exercise 2: Lifecycle Motor Controller",id:"exercise-2-lifecycle-motor-controller",level:3},{value:"Exercise 3: Tunable Controller",id:"exercise-3-tunable-controller",level:3},{value:"Assessment Questions",id:"assessment-questions",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"python-development-with-rclpy",children:"Python Development with rclpy"})}),"\n",(0,l.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,l.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Configure"})," multi-threaded executors for concurrent node execution"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Implement"})," callback groups for controlling execution flow"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Create"})," lifecycle nodes for deterministic startup and shutdown"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Handle"})," parameters dynamically in running nodes"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Design"})," robust error handling patterns for robot systems"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Completed Chapter 2: Nodes, Topics, and Services"}),"\n",(0,l.jsx)(n.li,{children:"Understanding of Python threading concepts"}),"\n",(0,l.jsx)(n.li,{children:"Familiarity with context managers and decorators"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"advanced-rclpy-concepts",children:"Advanced rclpy Concepts"}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"rclpy"})," library provides Python bindings for ROS 2. While basic usage is straightforward, building production-ready humanoid robot software requires understanding advanced execution patterns."]}),"\n",(0,l.jsx)(n.mermaid,{value:'graph TD\n    subgraph "rclpy Execution Model"\n        E[Executor] --\x3e CG1[Callback Group 1]\n        E --\x3e CG2[Callback Group 2]\n        CG1 --\x3e CB1[Timer Callback]\n        CG1 --\x3e CB2[Subscription Callback]\n        CG2 --\x3e CB3[Service Callback]\n        CG2 --\x3e CB4[Action Callback]\n    end\n\n    style E fill:#e3f2fd\n    style CG1 fill:#c8e6c9\n    style CG2 fill:#ffe0b2'}),"\n",(0,l.jsx)(n.h2,{id:"executors-and-callback-groups",children:"Executors and Callback Groups"}),"\n",(0,l.jsx)(n.h3,{id:"understanding-executors",children:"Understanding Executors"}),"\n",(0,l.jsx)(n.p,{children:"Executors determine how callbacks are processed. ROS 2 provides two main executors:"}),"\n",(0,l.jsxs)(n.table,{children:[(0,l.jsx)(n.thead,{children:(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.th,{children:"Executor"}),(0,l.jsx)(n.th,{children:"Behavior"}),(0,l.jsx)(n.th,{children:"Use Case"})]})}),(0,l.jsxs)(n.tbody,{children:[(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"SingleThreadedExecutor"})}),(0,l.jsx)(n.td,{children:"Sequential callback execution"}),(0,l.jsx)(n.td,{children:"Simple nodes, deterministic behavior"})]}),(0,l.jsxs)(n.tr,{children:[(0,l.jsx)(n.td,{children:(0,l.jsx)(n.code,{children:"MultiThreadedExecutor"})}),(0,l.jsx)(n.td,{children:"Parallel callback execution"}),(0,l.jsx)(n.td,{children:"High-frequency sensors, multiple services"})]})]})]}),"\n",(0,l.jsx)(n.h3,{id:"multi-threaded-execution",children:"Multi-Threaded Execution"}),"\n",(0,l.jsx)(n.p,{children:"For humanoid robots processing multiple sensor streams simultaneously:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""Multi-threaded node for parallel sensor processing."""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.executors import MultiThreadedExecutor\nfrom rclpy.callback_groups import MutuallyExclusiveCallbackGroup, ReentrantCallbackGroup\nfrom sensor_msgs.msg import Imu, JointState, Image\nfrom threading import Lock\n\n\nclass MultiSensorProcessor(Node):\n    """Process multiple sensor streams concurrently."""\n\n    def __init__(self):\n        super().__init__(\'multi_sensor_processor\')\n\n        # Create callback groups\n        # ReentrantCallbackGroup: Callbacks can run in parallel\n        self.sensor_cb_group = ReentrantCallbackGroup()\n\n        # MutuallyExclusiveCallbackGroup: Only one callback at a time\n        self.state_cb_group = MutuallyExclusiveCallbackGroup()\n\n        # Thread-safe data storage\n        self._lock = Lock()\n        self._latest_imu = None\n        self._latest_joints = None\n\n        # Subscriptions with callback groups\n        self.imu_sub = self.create_subscription(\n            Imu, \'/imu/data\', self.imu_callback, 10,\n            callback_group=self.sensor_cb_group\n        )\n\n        self.joint_sub = self.create_subscription(\n            JointState, \'/joint_states\', self.joint_callback, 10,\n            callback_group=self.sensor_cb_group\n        )\n\n        self.image_sub = self.create_subscription(\n            Image, \'/camera/image_raw\', self.image_callback, 10,\n            callback_group=self.sensor_cb_group\n        )\n\n        # Timer for fusion (uses exclusive group to prevent data races)\n        self.fusion_timer = self.create_timer(\n            0.01, self.fusion_callback,  # 100 Hz fusion rate\n            callback_group=self.state_cb_group\n        )\n\n        self.get_logger().info(\'Multi-sensor processor initialized\')\n\n    def imu_callback(self, msg: Imu):\n        """Process IMU data - can run in parallel with other sensors."""\n        with self._lock:\n            self._latest_imu = msg\n        self.get_logger().debug(\'IMU data received\')\n\n    def joint_callback(self, msg: JointState):\n        """Process joint state data."""\n        with self._lock:\n            self._latest_joints = msg\n        self.get_logger().debug(\'Joint state received\')\n\n    def image_callback(self, msg: Image):\n        """Process camera image."""\n        # Heavy computation - runs in parallel with other callbacks\n        self.get_logger().debug(\n            f\'Image received: {msg.width}x{msg.height}\'\n        )\n\n    def fusion_callback(self):\n        """Fuse sensor data - exclusive execution."""\n        with self._lock:\n            if self._latest_imu and self._latest_joints:\n                # Perform sensor fusion\n                self.get_logger().debug(\'Fusing sensor data\')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = MultiSensorProcessor()\n\n    # Use multi-threaded executor with 4 threads\n    executor = MultiThreadedExecutor(num_threads=4)\n    executor.add_node(node)\n\n    try:\n        executor.spin()\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,l.jsx)(n.h2,{id:"lifecycle-nodes",children:"Lifecycle Nodes"}),"\n",(0,l.jsx)(n.p,{children:"Lifecycle (managed) nodes provide deterministic state transitions, essential for safety-critical humanoid robot systems."}),"\n",(0,l.jsx)(n.mermaid,{value:"stateDiagram-v2\n    [*] --\x3e Unconfigured: create\n    Unconfigured --\x3e Inactive: configure\n    Inactive --\x3e Unconfigured: cleanup\n    Inactive --\x3e Active: activate\n    Active --\x3e Inactive: deactivate\n    Active --\x3e Finalized: shutdown\n    Inactive --\x3e Finalized: shutdown\n    Unconfigured --\x3e Finalized: shutdown\n    Finalized --\x3e [*]"}),"\n",(0,l.jsx)(n.h3,{id:"implementing-a-lifecycle-node",children:"Implementing a Lifecycle Node"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""Lifecycle node for humanoid motor controller."""\n\nimport rclpy\nfrom rclpy.lifecycle import Node as LifecycleNode\nfrom rclpy.lifecycle import State, TransitionCallbackReturn\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64MultiArray\n\n\nclass MotorControllerLifecycle(LifecycleNode):\n    """Lifecycle-managed motor controller for humanoid robot."""\n\n    def __init__(self, **kwargs):\n        super().__init__(\'motor_controller\', **kwargs)\n\n        self._joint_command_sub = None\n        self._joint_state_pub = None\n        self._control_timer = None\n\n        self.get_logger().info(\'Motor controller node created (unconfigured)\')\n\n    def on_configure(self, state: State) -> TransitionCallbackReturn:\n        """Configure the node - initialize but don\'t activate."""\n        self.get_logger().info(\'Configuring motor controller...\')\n\n        # Declare and get parameters\n        self.declare_parameter(\'control_frequency\', 1000.0)\n        self.declare_parameter(\'motor_ids\', [1, 2, 3, 4, 5, 6])\n\n        self._control_freq = self.get_parameter(\'control_frequency\').value\n        self._motor_ids = self.get_parameter(\'motor_ids\').value\n\n        # Create publishers/subscribers (but don\'t enable yet)\n        self._joint_state_pub = self.create_publisher(\n            JointState, \'/joint_states\', 10\n        )\n\n        self._joint_command_sub = self.create_subscription(\n            Float64MultiArray, \'/joint_commands\',\n            self._command_callback, 10\n        )\n\n        self.get_logger().info(\n            f\'Configured: {len(self._motor_ids)} motors at {self._control_freq} Hz\'\n        )\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_activate(self, state: State) -> TransitionCallbackReturn:\n        """Activate the node - start control loop."""\n        self.get_logger().info(\'Activating motor controller...\')\n\n        # Initialize hardware connection here\n        if not self._initialize_hardware():\n            self.get_logger().error(\'Hardware initialization failed!\')\n            return TransitionCallbackReturn.FAILURE\n\n        # Start control timer\n        period = 1.0 / self._control_freq\n        self._control_timer = self.create_timer(period, self._control_loop)\n\n        self.get_logger().info(\'Motor controller ACTIVE\')\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_deactivate(self, state: State) -> TransitionCallbackReturn:\n        """Deactivate - stop control but keep configuration."""\n        self.get_logger().info(\'Deactivating motor controller...\')\n\n        # Stop control timer\n        if self._control_timer:\n            self._control_timer.cancel()\n            self._control_timer = None\n\n        # Put motors in safe state\n        self._safe_stop_motors()\n\n        self.get_logger().info(\'Motor controller INACTIVE\')\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_cleanup(self, state: State) -> TransitionCallbackReturn:\n        """Cleanup - release all resources."""\n        self.get_logger().info(\'Cleaning up motor controller...\')\n\n        # Destroy publishers/subscribers\n        if self._joint_state_pub:\n            self.destroy_publisher(self._joint_state_pub)\n        if self._joint_command_sub:\n            self.destroy_subscription(self._joint_command_sub)\n\n        self.get_logger().info(\'Motor controller cleaned up\')\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_shutdown(self, state: State) -> TransitionCallbackReturn:\n        """Shutdown - final cleanup before destruction."""\n        self.get_logger().info(\'Shutting down motor controller...\')\n        self._safe_stop_motors()\n        return TransitionCallbackReturn.SUCCESS\n\n    def on_error(self, state: State) -> TransitionCallbackReturn:\n        """Handle errors - attempt recovery or fail gracefully."""\n        self.get_logger().error(f\'Error in state: {state.label}\')\n        self._safe_stop_motors()\n        return TransitionCallbackReturn.SUCCESS\n\n    def _initialize_hardware(self) -> bool:\n        """Initialize motor hardware connection."""\n        # Actual hardware init would go here\n        self.get_logger().info(\'Hardware initialized (simulated)\')\n        return True\n\n    def _safe_stop_motors(self):\n        """Command all motors to safe stop position."""\n        self.get_logger().info(\'Motors commanded to safe stop\')\n\n    def _command_callback(self, msg: Float64MultiArray):\n        """Handle incoming joint commands."""\n        if self._control_timer is None:\n            self.get_logger().warn(\'Received command while inactive\')\n            return\n        # Process commands...\n\n    def _control_loop(self):\n        """Main control loop - called at control frequency."""\n        # Read sensors, compute control, write to actuators\n        msg = JointState()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        self._joint_state_pub.publish(msg)\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = MotorControllerLifecycle()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,l.jsx)(n.h3,{id:"managing-lifecycle-nodes",children:"Managing Lifecycle Nodes"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"# List lifecycle nodes\nros2 lifecycle nodes\n\n# Get current state\nros2 lifecycle get /motor_controller\n\n# Trigger transitions\nros2 lifecycle set /motor_controller configure\nros2 lifecycle set /motor_controller activate\nros2 lifecycle set /motor_controller deactivate\nros2 lifecycle set /motor_controller cleanup\nros2 lifecycle set /motor_controller shutdown\n"})}),"\n",(0,l.jsx)(n.h2,{id:"dynamic-parameters",children:"Dynamic Parameters"}),"\n",(0,l.jsx)(n.p,{children:"Parameters can be changed at runtime for tuning without restarting nodes:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\"\"\"Node with dynamic parameter handling.\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rcl_interfaces.msg import SetParametersResult\n\n\nclass DynamicParameterNode(Node):\n    \"\"\"Node that responds to parameter changes.\"\"\"\n\n    def __init__(self):\n        super().__init__('dynamic_params')\n\n        # Declare parameters with descriptors\n        self.declare_parameter('kp', 100.0)\n        self.declare_parameter('kd', 10.0)\n        self.declare_parameter('ki', 1.0)\n\n        # Get initial values\n        self._kp = self.get_parameter('kp').value\n        self._kd = self.get_parameter('kd').value\n        self._ki = self.get_parameter('ki').value\n\n        # Register parameter callback\n        self.add_on_set_parameters_callback(self._parameter_callback)\n\n        self.get_logger().info(\n            f'PID gains: kp={self._kp}, kd={self._kd}, ki={self._ki}'\n        )\n\n    def _parameter_callback(self, params) -> SetParametersResult:\n        \"\"\"Handle parameter updates.\"\"\"\n        for param in params:\n            if param.name == 'kp':\n                if param.value < 0:\n                    return SetParametersResult(\n                        successful=False,\n                        reason='kp must be non-negative'\n                    )\n                self._kp = param.value\n                self.get_logger().info(f'Updated kp to {self._kp}')\n\n            elif param.name == 'kd':\n                if param.value < 0:\n                    return SetParametersResult(\n                        successful=False,\n                        reason='kd must be non-negative'\n                    )\n                self._kd = param.value\n                self.get_logger().info(f'Updated kd to {self._kd}')\n\n            elif param.name == 'ki':\n                self._ki = param.value\n                self.get_logger().info(f'Updated ki to {self._ki}')\n\n        return SetParametersResult(successful=True)\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = DynamicParameterNode()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-bash",children:"# Set parameter at runtime\nros2 param set /dynamic_params kp 150.0\n\n# Get current value\nros2 param get /dynamic_params kp\n\n# List all parameters\nros2 param list /dynamic_params\n"})}),"\n",(0,l.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,l.jsx)(n.h3,{id:"exercise-1-multi-threaded-sensor-fusion",children:"Exercise 1: Multi-Threaded Sensor Fusion"}),"\n",(0,l.jsx)(n.p,{children:"Create a node that:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Subscribes to IMU (1000 Hz), camera (30 Hz), and LiDAR (10 Hz)"}),"\n",(0,l.jsx)(n.li,{children:"Uses appropriate callback groups for concurrent processing"}),"\n",(0,l.jsx)(n.li,{children:"Fuses data when all sensors have new readings"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"exercise-2-lifecycle-motor-controller",children:"Exercise 2: Lifecycle Motor Controller"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Extend the lifecycle motor controller to include actual state publishing"}),"\n",(0,l.jsx)(n.li,{children:"Add a watchdog timer that deactivates if no commands received for 1 second"}),"\n",(0,l.jsx)(n.li,{children:"Test all state transitions via CLI"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"exercise-3-tunable-controller",children:"Exercise 3: Tunable Controller"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Create a PID controller node with tunable gains"}),"\n",(0,l.jsx)(n.li,{children:"Implement parameter validation (all gains positive, reasonable ranges)"}),"\n",(0,l.jsx)(n.li,{children:"Add a service to reset the integral term"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"assessment-questions",children:"Assessment Questions"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsxs)(n.strong,{children:["Why would you use a ",(0,l.jsx)(n.code,{children:"MutuallyExclusiveCallbackGroup"})," versus a ",(0,l.jsx)(n.code,{children:"ReentrantCallbackGroup"}),"?"]})}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"What are the benefits of lifecycle nodes for safety-critical robot systems?"})}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"How do you ensure thread safety when multiple callbacks access shared data?"})}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:(0,l.jsx)(n.strong,{children:"Design the callback group architecture for a humanoid robot with 6 cameras, 2 IMUs, and 24 joint motors."})}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,l.jsx)(n.p,{children:"In this chapter, we explored advanced rclpy features:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Executors"})," control how callbacks are scheduled and executed"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Callback groups"})," enable fine-grained control over concurrency"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Lifecycle nodes"})," provide deterministic startup and shutdown behavior"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"Dynamic parameters"})," allow runtime tuning without node restarts"]}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"These patterns are essential for building robust, maintainable humanoid robot software. The next chapter covers URDF modeling for humanoid robots."}),"\n",(0,l.jsx)(n.hr,{}),"\n",(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.strong,{children:"Next"}),": ",(0,l.jsx)(n.a,{href:"./urdf-humanoids",children:"URDF for Humanoid Robots"})]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}}}]);