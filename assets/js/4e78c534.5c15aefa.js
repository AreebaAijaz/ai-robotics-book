"use strict";(globalThis.webpackChunkai_robotics_book=globalThis.webpackChunkai_robotics_book||[]).push([[8982],{7946:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>t,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-2-simulation/gazebo-basics","title":"Gazebo Basics","description":"Introduction to Gazebo physics simulation for humanoid robotics development","source":"@site/docs/module-2-simulation/01-gazebo-basics.md","sourceDirName":"module-2-simulation","slug":"/module-2-simulation/gazebo-basics","permalink":"/ai-robotics-book/docs/module-2-simulation/gazebo-basics","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Gazebo Basics","description":"Introduction to Gazebo physics simulation for humanoid robotics development"},"sidebar":"tutorialSidebar","previous":{"title":"Module 2: Simulation Environments","permalink":"/ai-robotics-book/docs/category/module-2-simulation-environments"},"next":{"title":"Unity Integration","permalink":"/ai-robotics-book/docs/module-2-simulation/unity-integration"}}');var o=i(4848),r=i(8453);const a={sidebar_position:1,title:"Gazebo Basics",description:"Introduction to Gazebo physics simulation for humanoid robotics development"},t="Gazebo Basics",l={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Introduction to Gazebo",id:"introduction-to-gazebo",level:2},{value:"Installation",id:"installation",level:2},{value:"Installing Gazebo Harmonic",id:"installing-gazebo-harmonic",level:3},{value:"Verify Installation",id:"verify-installation",level:3},{value:"Creating Simulation Worlds",id:"creating-simulation-worlds",level:2},{value:"SDF World Format",id:"sdf-world-format",level:3},{value:"Physics Engine Configuration",id:"physics-engine-configuration",level:3},{value:"Spawning Robots",id:"spawning-robots",level:2},{value:"Converting URDF for Gazebo",id:"converting-urdf-for-gazebo",level:3},{value:"Launch File for Simulation",id:"launch-file-for-simulation",level:3},{value:"ROS 2 - Gazebo Communication",id:"ros-2---gazebo-communication",level:2},{value:"Parameter Bridge",id:"parameter-bridge",level:3},{value:"gz_ros2_control",id:"gz_ros2_control",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Create a Walking Environment",id:"exercise-1-create-a-walking-environment",level:3},{value:"Exercise 2: Spawn and Control Robot",id:"exercise-2-spawn-and-control-robot",level:3},{value:"Exercise 3: Add Sensors",id:"exercise-3-add-sensors",level:3},{value:"Assessment Questions",id:"assessment-questions",level:2},{value:"Summary",id:"summary",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"gazebo-basics",children:"Gazebo Basics"})}),"\n",(0,o.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,o.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Install and configure"})," Gazebo Harmonic for ROS 2 development"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Create"})," simulation worlds with terrain and objects"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Spawn"})," URDF robots into Gazebo simulations"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Configure"})," physics parameters for realistic humanoid simulation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Interface"})," between Gazebo and ROS 2 using ros_gz bridges"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Completed Module 1: ROS 2 Fundamentals"}),"\n",(0,o.jsx)(e.li,{children:"URDF model of a humanoid robot"}),"\n",(0,o.jsx)(e.li,{children:"Ubuntu 24.04 with ROS 2 Jazzy"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"introduction-to-gazebo",children:"Introduction to Gazebo"}),"\n",(0,o.jsxs)(e.p,{children:["Gazebo is a powerful physics simulation environment widely used in robotics research and development. The latest generation, ",(0,o.jsx)(e.strong,{children:"Gazebo Harmonic"})," (formerly Ignition Gazebo), provides:"]}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"High-fidelity physics"}),": Multiple physics engines (DART, Bullet, ODE)"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Sensor simulation"}),": Cameras, LiDAR, IMU, contact sensors"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"ROS 2 integration"}),": Native bridges for seamless communication"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Scalability"}),": Distributed simulation across multiple machines"]}),"\n"]}),"\n",(0,o.jsx)(e.mermaid,{value:'graph LR\n    subgraph "Gazebo Simulation"\n        W[World] --\x3e P[Physics Engine]\n        W --\x3e S[Sensors]\n        W --\x3e R[Robot Model]\n        P --\x3e R\n        S --\x3e R\n    end\n\n    subgraph "ROS 2"\n        B[ros_gz Bridge]\n        N[ROS 2 Nodes]\n    end\n\n    R <--\x3e|gz_ros2_control| B\n    S <--\x3e|Camera, LiDAR| B\n    B <--\x3e N\n\n    style W fill:#e3f2fd\n    style B fill:#c8e6c9'}),"\n",(0,o.jsx)(e.h2,{id:"installation",children:"Installation"}),"\n",(0,o.jsx)(e.h3,{id:"installing-gazebo-harmonic",children:"Installing Gazebo Harmonic"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:'# Add Gazebo repository\nsudo curl https://packages.osrfoundation.org/gazebo.gpg \\\n    --output /usr/share/keyrings/pkgs-osrf-archive-keyring.gpg\n\necho "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/pkgs-osrf-archive-keyring.gpg] http://packages.osrfoundation.org/gazebo/ubuntu-stable $(lsb_release -cs) main" \\\n    | sudo tee /etc/apt/sources.list.d/gazebo-stable.list > /dev/null\n\n# Install Gazebo Harmonic\nsudo apt update\nsudo apt install gz-harmonic\n\n# Install ROS 2 Gazebo packages\nsudo apt install ros-jazzy-ros-gz\n'})}),"\n",(0,o.jsx)(e.h3,{id:"verify-installation",children:"Verify Installation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Launch empty Gazebo world\ngz sim empty.sdf\n\n# Check ROS-Gazebo bridge\nros2 run ros_gz_bridge parameter_bridge --help\n"})}),"\n",(0,o.jsx)(e.h2,{id:"creating-simulation-worlds",children:"Creating Simulation Worlds"}),"\n",(0,o.jsx)(e.h3,{id:"sdf-world-format",children:"SDF World Format"}),"\n",(0,o.jsxs)(e.p,{children:["Gazebo uses ",(0,o.jsx)(e.strong,{children:"Simulation Description Format (SDF)"})," for world definitions:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n<sdf version="1.8">\n  <world name="humanoid_world">\n    \x3c!-- Physics configuration --\x3e\n    <physics name="1ms" type="dart">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n    </physics>\n\n    \x3c!-- Lighting --\x3e\n    <light type="directional" name="sun">\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <specular>0.2 0.2 0.2 1</specular>\n      <direction>-0.5 0.1 -0.9</direction>\n    </light>\n\n    \x3c!-- Ground plane --\x3e\n    <model name="ground_plane">\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>1.0</mu>\n                <mu2>1.0</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <material>\n            <ambient>0.8 0.8 0.8 1</ambient>\n            <diffuse>0.8 0.8 0.8 1</diffuse>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Obstacles for navigation --\x3e\n    <model name="box_obstacle">\n      <pose>3 0 0.5 0 0 0</pose>\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <box><size>1 1 1</size></box>\n          </geometry>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <box><size>1 1 1</size></box>\n          </geometry>\n          <material>\n            <ambient>0.8 0.2 0.2 1</ambient>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n  </world>\n</sdf>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"physics-engine-configuration",children:"Physics Engine Configuration"}),"\n",(0,o.jsx)(e.p,{children:"For humanoid simulation, physics parameters are critical:"}),"\n",(0,o.jsxs)(e.table,{children:[(0,o.jsx)(e.thead,{children:(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.th,{children:"Parameter"}),(0,o.jsx)(e.th,{children:"Value"}),(0,o.jsx)(e.th,{children:"Purpose"})]})}),(0,o.jsxs)(e.tbody,{children:[(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:(0,o.jsx)(e.code,{children:"max_step_size"})}),(0,o.jsx)(e.td,{children:"0.001"}),(0,o.jsx)(e.td,{children:"1ms steps for stable contact"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:(0,o.jsx)(e.code,{children:"real_time_factor"})}),(0,o.jsx)(e.td,{children:"1.0"}),(0,o.jsx)(e.td,{children:"Real-time simulation"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:(0,o.jsx)(e.code,{children:"solver_iterations"})}),(0,o.jsx)(e.td,{children:"50"}),(0,o.jsx)(e.td,{children:"Contact accuracy"})]}),(0,o.jsxs)(e.tr,{children:[(0,o.jsx)(e.td,{children:(0,o.jsx)(e.code,{children:"contact_surface_layer"})}),(0,o.jsx)(e.td,{children:"0.001"}),(0,o.jsx)(e.td,{children:"Penetration tolerance"})]})]})]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'<physics name="humanoid_physics" type="dart">\n  <max_step_size>0.001</max_step_size>\n  <real_time_factor>1.0</real_time_factor>\n  <dart>\n    <solver>\n      <solver_type>dantzig</solver_type>\n    </solver>\n    <collision_detector>bullet</collision_detector>\n  </dart>\n</physics>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"spawning-robots",children:"Spawning Robots"}),"\n",(0,o.jsx)(e.h3,{id:"converting-urdf-for-gazebo",children:"Converting URDF for Gazebo"}),"\n",(0,o.jsx)(e.p,{children:"Gazebo requires additional tags for simulation. Add Gazebo-specific elements:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Add to URDF for Gazebo compatibility --\x3e\n<gazebo reference="torso">\n  <material>Gazebo/Grey</material>\n  <mu1>0.8</mu1>\n  <mu2>0.8</mu2>\n</gazebo>\n\n<gazebo reference="left_foot">\n  <material>Gazebo/Black</material>\n  <mu1>1.0</mu1>  \x3c!-- High friction for feet --\x3e\n  <mu2>1.0</mu2>\n  <kp>1000000.0</kp>\n  <kd>100.0</kd>\n</gazebo>\n\n\x3c!-- IMU sensor --\x3e\n<gazebo reference="imu_link">\n  <sensor name="imu_sensor" type="imu">\n    <always_on>true</always_on>\n    <update_rate>1000</update_rate>\n    <imu>\n      <angular_velocity>\n        <x><noise type="gaussian"><mean>0.0</mean><stddev>0.0002</stddev></noise></x>\n        <y><noise type="gaussian"><mean>0.0</mean><stddev>0.0002</stddev></noise></y>\n        <z><noise type="gaussian"><mean>0.0</mean><stddev>0.0002</stddev></noise></z>\n      </angular_velocity>\n      <linear_acceleration>\n        <x><noise type="gaussian"><mean>0.0</mean><stddev>0.017</stddev></noise></x>\n        <y><noise type="gaussian"><mean>0.0</mean><stddev>0.017</stddev></noise></y>\n        <z><noise type="gaussian"><mean>0.0</mean><stddev>0.017</stddev></noise></z>\n      </linear_acceleration>\n    </imu>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,o.jsx)(e.h3,{id:"launch-file-for-simulation",children:"Launch File for Simulation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n\"\"\"Launch Gazebo simulation with humanoid robot.\"\"\"\n\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch.substitutions import LaunchConfiguration, Command, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\n\ndef generate_launch_description():\n    pkg_humanoid = FindPackageShare('humanoid_description')\n    pkg_ros_gz_sim = FindPackageShare('ros_gz_sim')\n\n    # Paths\n    urdf_file = PathJoinSubstitution([pkg_humanoid, 'urdf', 'humanoid.urdf.xacro'])\n    world_file = PathJoinSubstitution([pkg_humanoid, 'worlds', 'humanoid_world.sdf'])\n\n    # Robot description\n    robot_description = Command(['xacro ', urdf_file])\n\n    return LaunchDescription([\n        # Launch Gazebo\n        IncludeLaunchDescription(\n            PythonLaunchDescriptionSource([\n                PathJoinSubstitution([pkg_ros_gz_sim, 'launch', 'gz_sim.launch.py'])\n            ]),\n            launch_arguments={'gz_args': ['-r ', world_file]}.items()\n        ),\n\n        # Robot state publisher\n        Node(\n            package='robot_state_publisher',\n            executable='robot_state_publisher',\n            parameters=[{'robot_description': robot_description}]\n        ),\n\n        # Spawn robot in Gazebo\n        Node(\n            package='ros_gz_sim',\n            executable='create',\n            arguments=[\n                '-name', 'humanoid',\n                '-topic', 'robot_description',\n                '-z', '1.0'  # Spawn 1m above ground\n            ],\n            output='screen'\n        ),\n\n        # Bridge for joint states\n        Node(\n            package='ros_gz_bridge',\n            executable='parameter_bridge',\n            arguments=[\n                '/world/humanoid_world/model/humanoid/joint_state@sensor_msgs/msg/JointState@gz.msgs.Model',\n                '/imu@sensor_msgs/msg/Imu@gz.msgs.IMU',\n            ],\n            output='screen'\n        ),\n    ])\n"})}),"\n",(0,o.jsx)(e.h2,{id:"ros-2---gazebo-communication",children:"ROS 2 - Gazebo Communication"}),"\n",(0,o.jsx)(e.h3,{id:"parameter-bridge",children:"Parameter Bridge"}),"\n",(0,o.jsxs)(e.p,{children:["The ",(0,o.jsx)(e.code,{children:"ros_gz_bridge"})," connects ROS 2 topics with Gazebo transport:"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Bridge syntax: /topic@ros_type@gz_type\nros2 run ros_gz_bridge parameter_bridge \\\n  /cmd_vel@geometry_msgs/msg/Twist@gz.msgs.Twist \\\n  /joint_states@sensor_msgs/msg/JointState@gz.msgs.Model \\\n  /camera/image@sensor_msgs/msg/Image@gz.msgs.Image\n"})}),"\n",(0,o.jsx)(e.h3,{id:"gz_ros2_control",children:"gz_ros2_control"}),"\n",(0,o.jsxs)(e.p,{children:["For joint control, use ",(0,o.jsx)(e.code,{children:"gz_ros2_control"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Add to URDF --\x3e\n<ros2_control name="GazeboSystem" type="system">\n  <hardware>\n    <plugin>gz_ros2_control/GazeboSimSystem</plugin>\n  </hardware>\n\n  <joint name="left_hip_pitch">\n    <command_interface name="effort">\n      <param name="min">-200</param>\n      <param name="max">200</param>\n    </command_interface>\n    <state_interface name="position"/>\n    <state_interface name="velocity"/>\n    <state_interface name="effort"/>\n  </joint>\n  \x3c!-- Repeat for other joints --\x3e\n</ros2_control>\n\n<gazebo>\n  <plugin filename="gz_ros2_control-system"\n          name="gz_ros2_control::GazeboSimROS2ControlPlugin">\n    <parameters>$(find humanoid_control)/config/controllers.yaml</parameters>\n  </plugin>\n</gazebo>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,o.jsx)(e.h3,{id:"exercise-1-create-a-walking-environment",children:"Exercise 1: Create a Walking Environment"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Create an SDF world with a flat ground and raised platforms"}),"\n",(0,o.jsx)(e.li,{children:"Add stairs with 0.15m rise and 0.30m run"}),"\n",(0,o.jsx)(e.li,{children:"Include visual markers for navigation waypoints"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"exercise-2-spawn-and-control-robot",children:"Exercise 2: Spawn and Control Robot"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Launch Gazebo with your humanoid URDF"}),"\n",(0,o.jsxs)(e.li,{children:["Create a bridge for ",(0,o.jsx)(e.code,{children:"/cmd_vel"})," commands"]}),"\n",(0,o.jsxs)(e.li,{children:["Verify joint states are published via ",(0,o.jsx)(e.code,{children:"ros2 topic echo"})]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"exercise-3-add-sensors",children:"Exercise 3: Add Sensors"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsx)(e.li,{children:"Add a camera sensor to the robot's head"}),"\n",(0,o.jsx)(e.li,{children:"Bridge the camera topic to ROS 2"}),"\n",(0,o.jsx)(e.li,{children:"Visualize the camera feed in RViz"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"assessment-questions",children:"Assessment Questions"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Why is a 1ms physics step size important for humanoid contact simulation?"})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsxs)(e.strong,{children:["What is the role of friction coefficients (",(0,o.jsx)(e.code,{children:"mu1"}),", ",(0,o.jsx)(e.code,{children:"mu2"}),") for foot-ground contact?"]})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Explain the difference between Gazebo transport and ROS 2 topics."})}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"How would you configure Gazebo for faster-than-real-time simulation during training?"})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"In this chapter, we covered Gazebo simulation basics:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Gazebo Harmonic"})," provides high-fidelity physics simulation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"SDF worlds"})," define environments with physics, lighting, and objects"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"URDF extensions"})," add simulation-specific properties like friction and sensors"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"ros_gz_bridge"})," enables communication between Gazebo and ROS 2"]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Next, we'll explore Unity integration for advanced rendering and machine learning scenarios."}),"\n",(0,o.jsx)(e.hr,{}),"\n",(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"Next"}),": ",(0,o.jsx)(e.a,{href:"./unity-integration",children:"Unity Integration"})]})]})}function m(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>t});var s=i(6540);const o={},r=s.createContext(o);function a(n){const e=s.useContext(r);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:a(n.components),s.createElement(r.Provider,{value:e},n.children)}}}]);