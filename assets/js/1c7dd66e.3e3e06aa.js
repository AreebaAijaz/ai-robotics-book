"use strict";(globalThis.webpackChunkai_robotics_book=globalThis.webpackChunkai_robotics_book||[]).push([[8423],{5930:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module-1-ros2/urdf-humanoids","title":"URDF for Humanoid Robots","description":"Model humanoid robots using URDF and Xacro for simulation and control","source":"@site/docs/module-1-ros2/04-urdf-humanoids.md","sourceDirName":"module-1-ros2","slug":"/module-1-ros2/urdf-humanoids","permalink":"/ai-robotics-book/docs/module-1-ros2/urdf-humanoids","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"URDF for Humanoid Robots","description":"Model humanoid robots using URDF and Xacro for simulation and control"},"sidebar":"tutorialSidebar","previous":{"title":"Python Development with rclpy","permalink":"/ai-robotics-book/docs/module-1-ros2/rclpy-integration"},"next":{"title":"Module 2: Simulation Environments","permalink":"/ai-robotics-book/docs/category/module-2-simulation-environments"}}');var o=i(4848),t=i(8453);const l={sidebar_position:4,title:"URDF for Humanoid Robots",description:"Model humanoid robots using URDF and Xacro for simulation and control"},s="URDF for Humanoid Robots",a={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Introduction to URDF",id:"introduction-to-urdf",level:2},{value:"Basic URDF Structure",id:"basic-urdf-structure",level:2},{value:"Minimal URDF Example",id:"minimal-urdf-example",level:3},{value:"Joint Types",id:"joint-types",level:3},{value:"Revolute Joint Example",id:"revolute-joint-example",level:3},{value:"Xacro: Modular Robot Descriptions",id:"xacro-modular-robot-descriptions",level:2},{value:"Converting URDF to Xacro",id:"converting-urdf-to-xacro",level:3},{value:"Complete Humanoid Leg Macro",id:"complete-humanoid-leg-macro",level:3},{value:"ROS 2 Integration",id:"ros-2-integration",level:2},{value:"Robot State Publisher",id:"robot-state-publisher",level:3},{value:"Processing Xacro Files",id:"processing-xacro-files",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Create a Simple Arm",id:"exercise-1-create-a-simple-arm",level:3},{value:"Exercise 2: Parameterize with Xacro",id:"exercise-2-parameterize-with-xacro",level:3},{value:"Exercise 3: Complete Upper Body",id:"exercise-3-complete-upper-body",level:3},{value:"Assessment Questions",id:"assessment-questions",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"urdf-for-humanoid-robots",children:"URDF for Humanoid Robots"})}),"\n",(0,o.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,o.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Create"})," URDF models representing humanoid robot kinematics"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Use"})," Xacro macros for modular, maintainable robot descriptions"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Define"})," joints, links, and their physical properties"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Visualize"})," robot models in RViz and prepare them for simulation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Integrate"})," URDF with ROS 2 for robot state publishing"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Completed Chapters 1-3 of Module 1"}),"\n",(0,o.jsx)(n.li,{children:"Basic understanding of 3D coordinate systems"}),"\n",(0,o.jsx)(n.li,{children:"Familiarity with XML syntax"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"introduction-to-urdf",children:"Introduction to URDF"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.strong,{children:"Unified Robot Description Format (URDF)"})," is an XML specification for describing robot models. For humanoid robots, URDF defines:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Links"}),": Rigid body segments (torso, limbs, head)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Joints"}),": Connections between links with motion constraints"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Inertials"}),": Mass and inertia properties for dynamics"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Visuals"}),": 3D meshes for visualization"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Collisions"}),": Simplified geometries for physics simulation"]}),"\n"]}),"\n",(0,o.jsx)(n.mermaid,{value:'graph TB\n    subgraph "Humanoid URDF Structure"\n        BASE[base_link] --\x3e TORSO[torso]\n        TORSO --\x3e HEAD[head]\n        TORSO --\x3e L_SHOULDER[left_shoulder]\n        TORSO --\x3e R_SHOULDER[right_shoulder]\n        TORSO --\x3e L_HIP[left_hip]\n        TORSO --\x3e R_HIP[right_hip]\n        L_SHOULDER --\x3e L_ELBOW[left_elbow]\n        L_ELBOW --\x3e L_WRIST[left_wrist]\n        R_SHOULDER --\x3e R_ELBOW[right_elbow]\n        R_ELBOW --\x3e R_WRIST[right_wrist]\n        L_HIP --\x3e L_KNEE[left_knee]\n        L_KNEE --\x3e L_ANKLE[left_ankle]\n        R_HIP --\x3e R_KNEE[right_knee]\n        R_KNEE --\x3e R_ANKLE[right_ankle]\n    end\n\n    style BASE fill:#e3f2fd\n    style TORSO fill:#c8e6c9'}),"\n",(0,o.jsx)(n.h2,{id:"basic-urdf-structure",children:"Basic URDF Structure"}),"\n",(0,o.jsx)(n.h3,{id:"minimal-urdf-example",children:"Minimal URDF Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_humanoid">\n  \x3c!-- Base link (root of the kinematic tree) --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.1 0.1 0.05"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0.0 0.0 0.8 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.1 0.1 0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.5"/>\n      <inertia ixx="0.001" ixy="0" ixz="0"\n               iyy="0.001" iyz="0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Torso link --\x3e\n  <link name="torso">\n    <visual>\n      <geometry>\n        <box size="0.3 0.2 0.4"/>\n      </geometry>\n      <material name="gray">\n        <color rgba="0.5 0.5 0.5 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.3 0.2 0.4"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="10.0"/>\n      <origin xyz="0 0 0.2"/>\n      <inertia ixx="0.1" ixy="0" ixz="0"\n               iyy="0.1" iyz="0" izz="0.05"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Joint connecting base to torso --\x3e\n  <joint name="base_to_torso" type="fixed">\n    <parent link="base_link"/>\n    <child link="torso"/>\n    <origin xyz="0 0 0.025" rpy="0 0 0"/>\n  </joint>\n</robot>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"joint-types",children:"Joint Types"}),"\n",(0,o.jsx)(n.p,{children:"URDF supports several joint types for humanoid robots:"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Joint Type"}),(0,o.jsx)(n.th,{children:"DOF"}),(0,o.jsx)(n.th,{children:"Use Case"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"revolute"})}),(0,o.jsx)(n.td,{children:"1"}),(0,o.jsx)(n.td,{children:"Shoulder, elbow, knee (with limits)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"continuous"})}),(0,o.jsx)(n.td,{children:"1"}),(0,o.jsx)(n.td,{children:"Wheels, rotating sensors"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"prismatic"})}),(0,o.jsx)(n.td,{children:"1"}),(0,o.jsx)(n.td,{children:"Linear actuators"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"fixed"})}),(0,o.jsx)(n.td,{children:"0"}),(0,o.jsx)(n.td,{children:"Rigid attachments"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"floating"})}),(0,o.jsx)(n.td,{children:"6"}),(0,o.jsx)(n.td,{children:"Free-floating base"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"planar"})}),(0,o.jsx)(n.td,{children:"3"}),(0,o.jsx)(n.td,{children:"2D motion (rarely used)"})]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"revolute-joint-example",children:"Revolute Joint Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Left shoulder pitch joint --\x3e\n<joint name="left_shoulder_pitch" type="revolute">\n  <parent link="torso"/>\n  <child link="left_upper_arm"/>\n  <origin xyz="0.15 0.12 0.35" rpy="0 0 0"/>\n  <axis xyz="0 1 0"/>  \x3c!-- Rotation around Y-axis --\x3e\n  <limit lower="-2.5" upper="2.5"\n         effort="100.0" velocity="3.14"/>\n  <dynamics damping="0.1" friction="0.0"/>\n</joint>\n'})}),"\n",(0,o.jsx)(n.h2,{id:"xacro-modular-robot-descriptions",children:"Xacro: Modular Robot Descriptions"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Xacro"})," (XML Macros) extends URDF with programming features:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Properties"}),": Variables for reuse"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Macros"}),": Parameterized URDF snippets"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Includes"}),": Split descriptions across files"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Math expressions"}),": Computed values"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"converting-urdf-to-xacro",children:"Converting URDF to Xacro"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid">\n  \x3c!-- Properties --\x3e\n  <xacro:property name="torso_mass" value="10.0"/>\n  <xacro:property name="torso_width" value="0.3"/>\n  <xacro:property name="torso_depth" value="0.2"/>\n  <xacro:property name="torso_height" value="0.4"/>\n\n  \x3c!-- Macro for a limb segment --\x3e\n  <xacro:macro name="limb_segment" params="name length radius mass">\n    <link name="${name}">\n      <visual>\n        <geometry>\n          <cylinder length="${length}" radius="${radius}"/>\n        </geometry>\n        <origin xyz="0 0 ${length/2}" rpy="0 0 0"/>\n        <material name="silver">\n          <color rgba="0.75 0.75 0.75 1.0"/>\n        </material>\n      </visual>\n      <collision>\n        <geometry>\n          <cylinder length="${length}" radius="${radius}"/>\n        </geometry>\n        <origin xyz="0 0 ${length/2}"/>\n      </collision>\n      <inertial>\n        <mass value="${mass}"/>\n        <origin xyz="0 0 ${length/2}"/>\n        <inertia\n          ixx="${mass * (3*radius*radius + length*length) / 12}"\n          ixy="0" ixz="0"\n          iyy="${mass * (3*radius*radius + length*length) / 12}"\n          iyz="0"\n          izz="${mass * radius * radius / 2}"/>\n      </inertial>\n    </link>\n  </xacro:macro>\n\n  \x3c!-- Use the macro --\x3e\n  <xacro:limb_segment name="left_upper_arm" length="0.25" radius="0.04" mass="1.5"/>\n  <xacro:limb_segment name="left_forearm" length="0.22" radius="0.035" mass="1.0"/>\n</robot>\n'})}),"\n",(0,o.jsx)(n.h3,{id:"complete-humanoid-leg-macro",children:"Complete Humanoid Leg Macro"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="humanoid_leg">\n\n  \x3c!-- Leg parameters --\x3e\n  <xacro:property name="upper_leg_length" value="0.35"/>\n  <xacro:property name="lower_leg_length" value="0.35"/>\n  <xacro:property name="leg_radius" value="0.05"/>\n  <xacro:property name="foot_length" value="0.20"/>\n  <xacro:property name="foot_width" value="0.10"/>\n  <xacro:property name="foot_height" value="0.05"/>\n\n  \x3c!-- Macro for complete leg assembly --\x3e\n  <xacro:macro name="humanoid_leg" params="prefix reflect">\n\n    \x3c!-- Hip yaw --\x3e\n    <joint name="${prefix}_hip_yaw" type="revolute">\n      <parent link="pelvis"/>\n      <child link="${prefix}_hip_yaw_link"/>\n      <origin xyz="${reflect * 0.1} 0 0" rpy="0 0 0"/>\n      <axis xyz="0 0 1"/>\n      <limit lower="-0.5" upper="0.5" effort="200" velocity="5"/>\n    </joint>\n\n    <link name="${prefix}_hip_yaw_link">\n      <inertial>\n        <mass value="0.5"/>\n        <inertia ixx="0.001" ixy="0" ixz="0"\n                 iyy="0.001" iyz="0" izz="0.001"/>\n      </inertial>\n    </link>\n\n    \x3c!-- Hip roll --\x3e\n    <joint name="${prefix}_hip_roll" type="revolute">\n      <parent link="${prefix}_hip_yaw_link"/>\n      <child link="${prefix}_hip_roll_link"/>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      <axis xyz="1 0 0"/>\n      <limit lower="-0.5" upper="0.5" effort="200" velocity="5"/>\n    </joint>\n\n    <link name="${prefix}_hip_roll_link">\n      <inertial>\n        <mass value="0.5"/>\n        <inertia ixx="0.001" ixy="0" ixz="0"\n                 iyy="0.001" iyz="0" izz="0.001"/>\n      </inertial>\n    </link>\n\n    \x3c!-- Hip pitch --\x3e\n    <joint name="${prefix}_hip_pitch" type="revolute">\n      <parent link="${prefix}_hip_roll_link"/>\n      <child link="${prefix}_upper_leg"/>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      <axis xyz="0 1 0"/>\n      <limit lower="-1.5" upper="1.5" effort="200" velocity="5"/>\n    </joint>\n\n    \x3c!-- Upper leg --\x3e\n    <link name="${prefix}_upper_leg">\n      <visual>\n        <geometry>\n          <cylinder length="${upper_leg_length}" radius="${leg_radius}"/>\n        </geometry>\n        <origin xyz="0 0 ${-upper_leg_length/2}"/>\n        <material name="dark_gray">\n          <color rgba="0.3 0.3 0.3 1.0"/>\n        </material>\n      </visual>\n      <collision>\n        <geometry>\n          <cylinder length="${upper_leg_length}" radius="${leg_radius}"/>\n        </geometry>\n        <origin xyz="0 0 ${-upper_leg_length/2}"/>\n      </collision>\n      <inertial>\n        <mass value="3.0"/>\n        <origin xyz="0 0 ${-upper_leg_length/2}"/>\n        <inertia ixx="0.03" ixy="0" ixz="0"\n                 iyy="0.03" iyz="0" izz="0.005"/>\n      </inertial>\n    </link>\n\n    \x3c!-- Knee --\x3e\n    <joint name="${prefix}_knee" type="revolute">\n      <parent link="${prefix}_upper_leg"/>\n      <child link="${prefix}_lower_leg"/>\n      <origin xyz="0 0 ${-upper_leg_length}" rpy="0 0 0"/>\n      <axis xyz="0 1 0"/>\n      <limit lower="-2.5" upper="0.0" effort="200" velocity="5"/>\n    </joint>\n\n    \x3c!-- Lower leg --\x3e\n    <link name="${prefix}_lower_leg">\n      <visual>\n        <geometry>\n          <cylinder length="${lower_leg_length}" radius="${leg_radius * 0.9}"/>\n        </geometry>\n        <origin xyz="0 0 ${-lower_leg_length/2}"/>\n        <material name="dark_gray"/>\n      </visual>\n      <collision>\n        <geometry>\n          <cylinder length="${lower_leg_length}" radius="${leg_radius * 0.9}"/>\n        </geometry>\n        <origin xyz="0 0 ${-lower_leg_length/2}"/>\n      </collision>\n      <inertial>\n        <mass value="2.5"/>\n        <origin xyz="0 0 ${-lower_leg_length/2}"/>\n        <inertia ixx="0.025" ixy="0" ixz="0"\n                 iyy="0.025" iyz="0" izz="0.004"/>\n      </inertial>\n    </link>\n\n    \x3c!-- Ankle pitch --\x3e\n    <joint name="${prefix}_ankle_pitch" type="revolute">\n      <parent link="${prefix}_lower_leg"/>\n      <child link="${prefix}_ankle_pitch_link"/>\n      <origin xyz="0 0 ${-lower_leg_length}" rpy="0 0 0"/>\n      <axis xyz="0 1 0"/>\n      <limit lower="-0.8" upper="0.8" effort="100" velocity="5"/>\n    </joint>\n\n    <link name="${prefix}_ankle_pitch_link">\n      <inertial>\n        <mass value="0.3"/>\n        <inertia ixx="0.0005" ixy="0" ixz="0"\n                 iyy="0.0005" iyz="0" izz="0.0005"/>\n      </inertial>\n    </link>\n\n    \x3c!-- Ankle roll --\x3e\n    <joint name="${prefix}_ankle_roll" type="revolute">\n      <parent link="${prefix}_ankle_pitch_link"/>\n      <child link="${prefix}_foot"/>\n      <origin xyz="0 0 0" rpy="0 0 0"/>\n      <axis xyz="1 0 0"/>\n      <limit lower="-0.5" upper="0.5" effort="100" velocity="5"/>\n    </joint>\n\n    \x3c!-- Foot --\x3e\n    <link name="${prefix}_foot">\n      <visual>\n        <geometry>\n          <box size="${foot_length} ${foot_width} ${foot_height}"/>\n        </geometry>\n        <origin xyz="${foot_length/4} 0 ${-foot_height/2}"/>\n        <material name="black">\n          <color rgba="0.1 0.1 0.1 1.0"/>\n        </material>\n      </visual>\n      <collision>\n        <geometry>\n          <box size="${foot_length} ${foot_width} ${foot_height}"/>\n        </geometry>\n        <origin xyz="${foot_length/4} 0 ${-foot_height/2}"/>\n      </collision>\n      <inertial>\n        <mass value="0.8"/>\n        <origin xyz="${foot_length/4} 0 ${-foot_height/2}"/>\n        <inertia ixx="0.002" ixy="0" ixz="0"\n                 iyy="0.004" iyz="0" izz="0.003"/>\n      </inertial>\n    </link>\n\n  </xacro:macro>\n\n  \x3c!-- Instantiate left and right legs --\x3e\n  <xacro:humanoid_leg prefix="left" reflect="1"/>\n  <xacro:humanoid_leg prefix="right" reflect="-1"/>\n\n</robot>\n'})}),"\n",(0,o.jsx)(n.h2,{id:"ros-2-integration",children:"ROS 2 Integration"}),"\n",(0,o.jsx)(n.h3,{id:"robot-state-publisher",children:"Robot State Publisher"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"robot_state_publisher"})," node broadcasts the robot's TF (transform) tree:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\"\"\"Launch file for humanoid robot visualization.\"\"\"\n\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom launch.substitutions import Command\nfrom ament_index_python.packages import get_package_share_directory\nimport os\n\n\ndef generate_launch_description():\n    pkg_share = get_package_share_directory('humanoid_description')\n    urdf_file = os.path.join(pkg_share, 'urdf', 'humanoid.urdf.xacro')\n\n    return LaunchDescription([\n        # Robot state publisher\n        Node(\n            package='robot_state_publisher',\n            executable='robot_state_publisher',\n            parameters=[{\n                'robot_description': Command(['xacro ', urdf_file])\n            }]\n        ),\n\n        # Joint state publisher GUI (for testing)\n        Node(\n            package='joint_state_publisher_gui',\n            executable='joint_state_publisher_gui',\n        ),\n\n        # RViz for visualization\n        Node(\n            package='rviz2',\n            executable='rviz2',\n            arguments=['-d', os.path.join(pkg_share, 'rviz', 'view_robot.rviz')]\n        ),\n    ])\n"})}),"\n",(0,o.jsx)(n.h3,{id:"processing-xacro-files",children:"Processing Xacro Files"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"# Generate URDF from Xacro\nxacro humanoid.urdf.xacro > humanoid.urdf\n\n# Check for errors\ncheck_urdf humanoid.urdf\n\n# Visualize in RViz\nros2 launch humanoid_description display.launch.py\n"})}),"\n",(0,o.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,o.jsx)(n.h3,{id:"exercise-1-create-a-simple-arm",children:"Exercise 1: Create a Simple Arm"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Create a 3-DOF arm (shoulder pitch, elbow, wrist) using URDF"}),"\n",(0,o.jsx)(n.li,{children:"Define appropriate joint limits for humanoid motion"}),"\n",(0,o.jsx)(n.li,{children:"Visualize in RViz using joint_state_publisher_gui"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"exercise-2-parameterize-with-xacro",children:"Exercise 2: Parameterize with Xacro"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Convert your arm URDF to Xacro"}),"\n",(0,o.jsx)(n.li,{children:"Create a macro that can generate left and right arms"}),"\n",(0,o.jsx)(n.li,{children:"Use properties for link dimensions and masses"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"exercise-3-complete-upper-body",children:"Exercise 3: Complete Upper Body"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Create a torso with neck and head"}),"\n",(0,o.jsx)(n.li,{children:"Add both arms using your macro"}),"\n",(0,o.jsx)(n.li,{children:"Ensure correct mass and inertia properties"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"assessment-questions",children:"Assessment Questions"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Why are inertial properties important for humanoid robot simulation?"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsxs)(n.strong,{children:["How does the ",(0,o.jsx)(n.code,{children:"reflect"})," parameter in the leg macro enable symmetric limb generation?"]})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"What considerations apply when defining joint limits for a humanoid robot?"})}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Explain the relationship between URDF, robot_state_publisher, and TF2."})}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"In this chapter, we covered URDF modeling for humanoid robots:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"URDF"})," defines robot kinematics through links, joints, and their properties"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Xacro"})," adds programming features for modular, maintainable descriptions"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Joint types"})," and limits constrain motion appropriately for humanoid kinematics"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"ROS 2 integration"})," through robot_state_publisher enables visualization and control"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"With a complete robot description, we're ready to move to Module 2, where we'll bring our humanoid model to life in simulation environments."}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Next Module"}),": ",(0,o.jsx)(n.a,{href:"../module-2-simulation/gazebo-basics",children:"Simulation Environments"})]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>s});var r=i(6540);const o={},t=r.createContext(o);function l(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);