"use strict";(globalThis.webpackChunkai_robotics_book=globalThis.webpackChunkai_robotics_book||[]).push([[8483],{5006:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-2-simulation/digital-twins","title":"Digital Twins","description":"Creating synchronized digital representations of physical humanoid robots","source":"@site/docs/module-2-simulation/04-digital-twins.md","sourceDirName":"module-2-simulation","slug":"/module-2-simulation/digital-twins","permalink":"/ai-robotics-book/docs/module-2-simulation/digital-twins","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Digital Twins","description":"Creating synchronized digital representations of physical humanoid robots"},"sidebar":"tutorialSidebar","previous":{"title":"Sensor Simulation","permalink":"/ai-robotics-book/docs/module-2-simulation/sensor-simulation"},"next":{"title":"Module 3: NVIDIA Isaac Platform","permalink":"/ai-robotics-book/docs/category/module-3-nvidia-isaac-platform"}}');var s=i(4848),a=i(8453);const o={sidebar_position:4,title:"Digital Twins",description:"Creating synchronized digital representations of physical humanoid robots"},l="Digital Twins",r={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"What is a Digital Twin?",id:"what-is-a-digital-twin",level:2},{value:"Digital Twin Architecture",id:"digital-twin-architecture",level:2},{value:"System Components",id:"system-components",level:3},{value:"ROS 2 Architecture",id:"ros-2-architecture",level:3},{value:"Bidirectional Synchronization",id:"bidirectional-synchronization",level:2},{value:"Physical-to-Digital (Monitoring Mode)",id:"physical-to-digital-monitoring-mode",level:3},{value:"Digital-to-Physical (Control Mode)",id:"digital-to-physical-control-mode",level:3},{value:"Monitoring and Analytics",id:"monitoring-and-analytics",level:2},{value:"Health Dashboard",id:"health-dashboard",level:3},{value:"Predictive Maintenance",id:"predictive-maintenance",level:2},{value:"Wear Model Simulation",id:"wear-model-simulation",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Basic Digital Twin",id:"exercise-1-basic-digital-twin",level:3},{value:"Exercise 2: Health Monitoring",id:"exercise-2-health-monitoring",level:3},{value:"Exercise 3: Predictive Maintenance",id:"exercise-3-predictive-maintenance",level:3},{value:"Assessment Questions",id:"assessment-questions",level:2},{value:"Summary",id:"summary",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"digital-twins",children:"Digital Twins"})}),"\n",(0,s.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,s.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Define"})," digital twin architectures for humanoid robots"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Implement"})," bidirectional synchronization between physical and virtual robots"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Design"})," monitoring dashboards for robot health and performance"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Create"})," predictive maintenance systems using simulation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Validate"})," control algorithms using digital twin verification"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Completed Chapters 1-3 of Module 2"}),"\n",(0,s.jsx)(e.li,{children:"Understanding of ROS 2 communication patterns"}),"\n",(0,s.jsx)(e.li,{children:"Familiarity with state estimation concepts"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"what-is-a-digital-twin",children:"What is a Digital Twin?"}),"\n",(0,s.jsxs)(e.p,{children:["A ",(0,s.jsx)(e.strong,{children:"digital twin"})," is a virtual representation of a physical robot that mirrors its state, behavior, and environment in real-time. Unlike simple simulation, digital twins maintain continuous synchronization with their physical counterparts."]}),"\n",(0,s.jsx)(e.mermaid,{value:'graph TB\n    subgraph "Physical Robot"\n        PR[Robot Hardware]\n        PS[Physical Sensors]\n        PA[Actuators]\n    end\n\n    subgraph "Digital Twin"\n        DT[Simulation Model]\n        DS[Virtual Sensors]\n        DA[Simulated Actuators]\n    end\n\n    subgraph "Services"\n        MON[Monitoring]\n        PRED[Prediction]\n        OPT[Optimization]\n    end\n\n    PR <--\x3e|State Sync| DT\n    PS --\x3e|Sensor Data| MON\n    DS --\x3e|Predicted Data| PRED\n    MON --\x3e OPT\n    PRED --\x3e OPT\n    OPT --\x3e|Commands| PA\n    OPT --\x3e|Parameters| DA\n\n    style DT fill:#e3f2fd\n    style MON fill:#c8e6c9\n    style PRED fill:#ffe0b2'}),"\n",(0,s.jsx)(e.h2,{id:"digital-twin-architecture",children:"Digital Twin Architecture"}),"\n",(0,s.jsx)(e.h3,{id:"system-components",children:"System Components"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Component"}),(0,s.jsx)(e.th,{children:"Physical Side"}),(0,s.jsx)(e.th,{children:"Digital Side"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"State"}),(0,s.jsx)(e.td,{children:"Joint positions, velocities"}),(0,s.jsx)(e.td,{children:"Simulated joint states"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Sensors"}),(0,s.jsx)(e.td,{children:"IMU, cameras, F/T"}),(0,s.jsx)(e.td,{children:"Simulated sensors"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Environment"}),(0,s.jsx)(e.td,{children:"Real world"}),(0,s.jsx)(e.td,{children:"Reconstructed scene"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:"Commands"}),(0,s.jsx)(e.td,{children:"Actuator inputs"}),(0,s.jsx)(e.td,{children:"Simulated inputs"})]})]})]}),"\n",(0,s.jsx)(e.h3,{id:"ros-2-architecture",children:"ROS 2 Architecture"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""Digital twin synchronization node."""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import WrenchStamped\nfrom std_msgs.msg import Float64MultiArray\nimport numpy as np\n\n\nclass DigitalTwinSync(Node):\n    """Synchronize physical robot with digital twin."""\n\n    def __init__(self):\n        super().__init__(\'digital_twin_sync\')\n\n        # QoS for real-time data\n        realtime_qos = QoSProfile(\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            depth=1\n        )\n\n        # Physical robot subscriptions\n        self.physical_joint_sub = self.create_subscription(\n            JointState, \'/physical/joint_states\',\n            self.physical_joint_callback, realtime_qos\n        )\n\n        self.physical_imu_sub = self.create_subscription(\n            Imu, \'/physical/imu/data\',\n            self.physical_imu_callback, realtime_qos\n        )\n\n        # Digital twin publishers (to simulation)\n        self.twin_joint_pub = self.create_publisher(\n            Float64MultiArray, \'/twin/joint_commands\', 10\n        )\n\n        # Synchronization state\n        self.sync_enabled = True\n        self.last_physical_state = None\n        self.state_error_threshold = 0.1  # radians\n\n        # Monitoring publishers\n        self.sync_error_pub = self.create_publisher(\n            Float64MultiArray, \'/twin/sync_error\', 10\n        )\n\n        # Sync timer\n        self.create_timer(0.001, self.sync_loop)  # 1 kHz\n\n        self.get_logger().info(\'Digital twin synchronization initialized\')\n\n    def physical_joint_callback(self, msg: JointState):\n        """Receive physical robot joint states."""\n        self.last_physical_state = msg\n\n    def physical_imu_callback(self, msg: Imu):\n        """Receive physical robot IMU data."""\n        # Could use for additional synchronization verification\n        pass\n\n    def sync_loop(self):\n        """Main synchronization loop."""\n        if not self.sync_enabled or self.last_physical_state is None:\n            return\n\n        # Send physical state to digital twin\n        cmd = Float64MultiArray()\n        cmd.data = list(self.last_physical_state.position)\n        self.twin_joint_pub.publish(cmd)\n\n    def compute_sync_error(self, physical: JointState, digital: JointState):\n        """Compute synchronization error between physical and digital."""\n        if len(physical.position) != len(digital.position):\n            self.get_logger().warn(\'Joint count mismatch\')\n            return None\n\n        errors = np.array(physical.position) - np.array(digital.position)\n        return errors\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = DigitalTwinSync()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,s.jsx)(e.h2,{id:"bidirectional-synchronization",children:"Bidirectional Synchronization"}),"\n",(0,s.jsx)(e.h3,{id:"physical-to-digital-monitoring-mode",children:"Physical-to-Digital (Monitoring Mode)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class PhysicalToDigitalSync:\n    """Sync physical robot state to digital twin for monitoring."""\n\n    def __init__(self, node: Node):\n        self.node = node\n\n        # State estimation\n        self.physical_state = None\n        self.digital_state = None\n\n        # Create command publisher for twin\n        self.twin_position_cmd = node.create_publisher(\n            Float64MultiArray, \'/twin/position_commands\', 10\n        )\n\n        # Subscribe to physical robot\n        node.create_subscription(\n            JointState, \'/physical/joint_states\',\n            self.on_physical_state, 10\n        )\n\n        # Subscribe to twin state (for verification)\n        node.create_subscription(\n            JointState, \'/twin/joint_states\',\n            self.on_digital_state, 10\n        )\n\n    def on_physical_state(self, msg: JointState):\n        """Update twin to match physical robot."""\n        self.physical_state = msg\n\n        # Command digital twin to follow\n        cmd = Float64MultiArray()\n        cmd.data = list(msg.position)\n        self.twin_position_cmd.publish(cmd)\n\n    def on_digital_state(self, msg: JointState):\n        """Verify twin state matches physical."""\n        self.digital_state = msg\n        self.verify_sync()\n\n    def verify_sync(self):\n        """Check synchronization accuracy."""\n        if self.physical_state is None or self.digital_state is None:\n            return\n\n        max_error = max(abs(p - d) for p, d in zip(\n            self.physical_state.position,\n            self.digital_state.position\n        ))\n\n        if max_error > 0.05:  # 0.05 rad threshold\n            self.node.get_logger().warn(\n                f\'Twin sync error: {max_error:.4f} rad\'\n            )\n'})}),"\n",(0,s.jsx)(e.h3,{id:"digital-to-physical-control-mode",children:"Digital-to-Physical (Control Mode)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class DigitalToPhysicalSync:\n    """Use digital twin for planning, execute on physical robot."""\n\n    def __init__(self, node: Node):\n        self.node = node\n\n        # Safety limits\n        self.max_velocity = 2.0  # rad/s\n        self.max_acceleration = 10.0  # rad/s^2\n\n        # Publishers\n        self.physical_cmd_pub = node.create_publisher(\n            Float64MultiArray, \'/physical/joint_commands\', 10\n        )\n\n        # Subscribe to twin planned trajectory\n        node.create_subscription(\n            Float64MultiArray, \'/twin/planned_trajectory\',\n            self.on_twin_plan, 10\n        )\n\n    def on_twin_plan(self, msg: Float64MultiArray):\n        """Receive plan from twin and execute safely on physical."""\n        # Validate commands against safety limits\n        if not self.validate_command(msg.data):\n            self.node.get_logger().error(\'Unsafe command rejected\')\n            return\n\n        # Forward to physical robot\n        self.physical_cmd_pub.publish(msg)\n\n    def validate_command(self, positions: list) -> bool:\n        """Validate command is within safe limits."""\n        # Add velocity/acceleration checking\n        return all(abs(p) < 3.14 for p in positions)  # Simple position limit\n'})}),"\n",(0,s.jsx)(e.h2,{id:"monitoring-and-analytics",children:"Monitoring and Analytics"}),"\n",(0,s.jsx)(e.h3,{id:"health-dashboard",children:"Health Dashboard"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'#!/usr/bin/env python3\n"""Robot health monitoring using digital twin comparison."""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64\nfrom dataclasses import dataclass\nfrom typing import Dict, List\nimport numpy as np\n\n\n@dataclass\nclass JointHealth:\n    """Health metrics for a single joint."""\n    name: str\n    position_error: float = 0.0\n    velocity_error: float = 0.0\n    effort_ratio: float = 1.0  # actual/expected effort\n    temperature: float = 25.0\n\n\nclass HealthMonitor(Node):\n    """Monitor robot health by comparing physical and digital twin."""\n\n    def __init__(self):\n        super().__init__(\'health_monitor\')\n\n        self.physical_state: JointState = None\n        self.digital_state: JointState = None\n        self.joint_health: Dict[str, JointHealth] = {}\n\n        # Subscriptions\n        self.create_subscription(\n            JointState, \'/physical/joint_states\',\n            self.physical_callback, 10\n        )\n        self.create_subscription(\n            JointState, \'/twin/joint_states\',\n            self.digital_callback, 10\n        )\n\n        # Health publishers\n        self.health_score_pub = self.create_publisher(\n            Float64, \'/health/overall_score\', 10\n        )\n\n        # Analysis timer (10 Hz)\n        self.create_timer(0.1, self.analyze_health)\n\n        # Alert thresholds\n        self.position_error_threshold = 0.1  # rad\n        self.effort_ratio_threshold = 1.5    # 50% more effort than expected\n\n    def physical_callback(self, msg: JointState):\n        self.physical_state = msg\n\n    def digital_callback(self, msg: JointState):\n        self.digital_state = msg\n\n    def analyze_health(self):\n        """Compare physical and digital states to assess health."""\n        if self.physical_state is None or self.digital_state is None:\n            return\n\n        health_scores = []\n\n        for i, name in enumerate(self.physical_state.name):\n            if name not in self.joint_health:\n                self.joint_health[name] = JointHealth(name=name)\n\n            health = self.joint_health[name]\n\n            # Position tracking error\n            if i < len(self.digital_state.position):\n                health.position_error = abs(\n                    self.physical_state.position[i] -\n                    self.digital_state.position[i]\n                )\n\n            # Effort ratio (actual vs expected)\n            if (i < len(self.physical_state.effort) and\n                i < len(self.digital_state.effort) and\n                abs(self.digital_state.effort[i]) > 0.1):\n                health.effort_ratio = (\n                    abs(self.physical_state.effort[i]) /\n                    abs(self.digital_state.effort[i])\n                )\n\n            # Compute joint health score (0-100)\n            position_score = max(0, 100 - health.position_error * 1000)\n            effort_score = max(0, 100 - abs(health.effort_ratio - 1.0) * 100)\n            joint_score = (position_score + effort_score) / 2\n            health_scores.append(joint_score)\n\n            # Log warnings\n            if health.position_error > self.position_error_threshold:\n                self.get_logger().warn(\n                    f\'Joint {name}: high position error {health.position_error:.3f} rad\'\n                )\n\n            if health.effort_ratio > self.effort_ratio_threshold:\n                self.get_logger().warn(\n                    f\'Joint {name}: high effort ratio {health.effort_ratio:.2f}\'\n                )\n\n        # Publish overall health score\n        overall_score = Float64()\n        overall_score.data = np.mean(health_scores) if health_scores else 0.0\n        self.health_score_pub.publish(overall_score)\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = HealthMonitor()\n    rclpy.spin(node)\n    node.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,s.jsx)(e.h2,{id:"predictive-maintenance",children:"Predictive Maintenance"}),"\n",(0,s.jsx)(e.h3,{id:"wear-model-simulation",children:"Wear Model Simulation"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class WearPredictor:\n    """Predict component wear using digital twin data."""\n\n    def __init__(self):\n        # Wear coefficients per joint (empirically determined)\n        self.wear_coefficients = {\n            \'hip_pitch\': 1e-9,\n            \'knee\': 1.5e-9,\n            \'ankle_pitch\': 1e-9,\n        }\n\n        # Accumulated wear (starts at 0)\n        self.accumulated_wear = {}\n\n        # Wear threshold for maintenance alert\n        self.maintenance_threshold = 0.01  # 1% wear\n\n    def update_wear(self, joint_name: str, effort: float, velocity: float, dt: float):\n        """Update wear estimate based on load and motion."""\n        if joint_name not in self.accumulated_wear:\n            self.accumulated_wear[joint_name] = 0.0\n\n        # Simple wear model: wear = k * |effort| * |velocity| * dt\n        coeff = self.wear_coefficients.get(joint_name, 1e-9)\n        wear_increment = coeff * abs(effort) * abs(velocity) * dt\n\n        self.accumulated_wear[joint_name] += wear_increment\n\n        return self.accumulated_wear[joint_name]\n\n    def predict_remaining_life(self, joint_name: str, avg_effort: float,\n                               avg_velocity: float) -> float:\n        """Predict remaining useful life in hours."""\n        if joint_name not in self.accumulated_wear:\n            return float(\'inf\')\n\n        current_wear = self.accumulated_wear[joint_name]\n        remaining_wear = self.maintenance_threshold - current_wear\n\n        if remaining_wear <= 0:\n            return 0.0\n\n        coeff = self.wear_coefficients.get(joint_name, 1e-9)\n        wear_rate = coeff * abs(avg_effort) * abs(avg_velocity)\n\n        if wear_rate <= 0:\n            return float(\'inf\')\n\n        return remaining_wear / wear_rate / 3600  # Convert seconds to hours\n\n    def get_maintenance_alerts(self) -> List[str]:\n        """Get list of joints needing maintenance."""\n        alerts = []\n        for joint, wear in self.accumulated_wear.items():\n            if wear > self.maintenance_threshold * 0.8:  # 80% of threshold\n                alerts.append(\n                    f\'{joint}: {wear/self.maintenance_threshold*100:.1f}% wear\'\n                )\n        return alerts\n'})}),"\n",(0,s.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,s.jsx)(e.h3,{id:"exercise-1-basic-digital-twin",children:"Exercise 1: Basic Digital Twin"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Set up a Gazebo simulation with your humanoid URDF"}),"\n",(0,s.jsx)(e.li,{children:"Create synchronization nodes to mirror joint states"}),"\n",(0,s.jsx)(e.li,{children:"Verify sync accuracy by comparing physical and digital states"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"exercise-2-health-monitoring",children:"Exercise 2: Health Monitoring"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Implement the health monitor node"}),"\n",(0,s.jsx)(e.li,{children:"Create a simple visualization (RViz or web dashboard)"}),"\n",(0,s.jsx)(e.li,{children:"Inject artificial faults and verify detection"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"exercise-3-predictive-maintenance",children:"Exercise 3: Predictive Maintenance"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Implement the wear predictor"}),"\n",(0,s.jsx)(e.li,{children:"Run a simulated walking motion for 1000 cycles"}),"\n",(0,s.jsx)(e.li,{children:"Generate maintenance predictions for each joint"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"assessment-questions",children:"Assessment Questions"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"What are the key differences between simulation and digital twins?"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Why is bidirectional synchronization important for digital twins?"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"How can digital twins improve robot maintenance?"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"What are the challenges of maintaining accurate synchronization?"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(e.p,{children:"This chapter covered digital twin concepts:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Digital twins"})," maintain synchronized virtual representations of physical robots"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Bidirectional sync"})," enables monitoring and predictive control"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Health monitoring"})," compares physical and expected behavior"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Predictive maintenance"})," uses simulation to estimate component wear"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"This completes Module 2 on Simulation. Next, we'll explore the NVIDIA Isaac platform for production-ready robotics AI."}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Next Module"}),": ",(0,s.jsx)(e.a,{href:"../module-3-isaac/isaac-sim-overview",children:"NVIDIA Isaac Platform"})]})]})}function h(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>l});var t=i(6540);const s={},a=t.createContext(s);function o(n){const e=t.useContext(a);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),t.createElement(a.Provider,{value:e},n.children)}}}]);